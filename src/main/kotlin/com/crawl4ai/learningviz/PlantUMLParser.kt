package com.crawl4ai.learningviz

import com.google.gson.Gson
import com.google.gson.JsonObject
import java.io.File
import java.nio.file.Files
import java.nio.file.Paths

/**
 * Parser for PlantUML sequence diagrams generated by AutoInstrumentor.
 */
class PlantUMLParser {

    data class PlantUMLDiagram(
        val sessionId: String,
        val content: String,
        val participants: List<String>,
        val calls: List<FunctionCall>,
        val statistics: Statistics
    )

    data class FunctionCall(
        val module: String,
        val functionName: String,
        val durationMs: Double,
        val memoryDeltaMb: Double,
        val cpuPercent: Double,
        val exception: String?,
        val lineNumber: Int,
        val isDead: Boolean = false
    )

    data class Statistics(
        val totalCalls: Int,
        val totalDurationMs: Double,
        val avgDurationMs: Double,
        val deadFunctions: Int,
        val totalFunctions: Int,
        val deadCodePercentage: Double
    )

    private val gson = Gson()

    /**
     * Parse a PlantUML file generated by AutoInstrumentor.
     */
    fun parsePlantUML(file: File): PlantUMLDiagram? {
        return try {
            val content = Files.readString(file.toPath())

            // Extract session ID from filename (e.g., "session_20250108_143022_0.puml")
            val sessionId = file.nameWithoutExtension

            // Parse participants
            val participants = mutableListOf<String>()
            val participantPattern = """participant\s+"([^"]+)"""".toRegex()
            participantPattern.findAll(content).forEach { match ->
                participants.add(match.groupValues[1])
            }

            // Parse function calls
            val calls = mutableListOf<FunctionCall>()
            val callPattern = """(\w+)\s*->\s*(\w+)\s*:\s*([^\n]+)""".toRegex()
            val notePattern = """note\s+(?:right|left|over)\s+[^:]*:\s*([^\n]+)""".toRegex()

            var currentCall: FunctionCall? = null
            val lines = content.lines()

            for (i in lines.indices) {
                val line = lines[i].trim()

                // Match function call
                val callMatch = callPattern.find(line)
                if (callMatch != null) {
                    val module = callMatch.groupValues[1]
                    val functionName = callMatch.groupValues[3]

                    currentCall = FunctionCall(
                        module = module,
                        functionName = functionName,
                        durationMs = 0.0,
                        memoryDeltaMb = 0.0,
                        cpuPercent = 0.0,
                        exception = null,
                        lineNumber = i + 1
                    )
                }

                // Match note (contains timing/memory info)
                val noteMatch = notePattern.find(line)
                if (noteMatch != null && currentCall != null) {
                    val noteText = noteMatch.groupValues[1]

                    // Parse timing (e.g., "1234.5ms")
                    val timeMatch = """([\d.]+)ms""".toRegex().find(noteText)
                    val duration = timeMatch?.groupValues?.get(1)?.toDoubleOrNull() ?: 0.0

                    // Parse memory (e.g., "+12.3 MB")
                    val memMatch = """([+-]?[\d.]+)\s*MB""".toRegex().find(noteText)
                    val memory = memMatch?.groupValues?.get(1)?.toDoubleOrNull() ?: 0.0

                    // Parse CPU (e.g., "CPU: 45.2%")
                    val cpuMatch = """CPU:\s*([\d.]+)%""".toRegex().find(noteText)
                    val cpu = cpuMatch?.groupValues?.get(1)?.toDoubleOrNull() ?: 0.0

                    // Check for exception
                    val exception = if (noteText.contains("Exception") || noteText.contains("Error")) {
                        noteText
                    } else null

                    currentCall = currentCall.copy(
                        durationMs = duration,
                        memoryDeltaMb = memory,
                        cpuPercent = cpu,
                        exception = exception
                    )

                    calls.add(currentCall)
                    currentCall = null
                }

                // Check for dead code marker
                if (line.contains("#FF6B6B") || line.contains("DEAD CODE")) {
                    currentCall = currentCall?.copy(isDead = true)
                }
            }

            // Calculate statistics
            val totalCalls = calls.size
            val totalDuration = calls.sumOf { it.durationMs }
            val avgDuration = if (totalCalls > 0) totalDuration / totalCalls else 0.0
            val deadFunctions = calls.count { it.isDead }
            val deadPercentage = if (totalCalls > 0) (deadFunctions.toDouble() / totalCalls) * 100 else 0.0

            val statistics = Statistics(
                totalCalls = totalCalls,
                totalDurationMs = totalDuration,
                avgDurationMs = avgDuration,
                deadFunctions = deadFunctions,
                totalFunctions = totalCalls,
                deadCodePercentage = deadPercentage
            )

            PlantUMLDiagram(
                sessionId = sessionId,
                content = content,
                participants = participants,
                calls = calls,
                statistics = statistics
            )
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    /**
     * Parse dead code report JSON.
     */
    fun parseDeadCodeReport(file: File): DeadCodeReport? {
        return try {
            val content = Files.readString(file.toPath())
            val json = gson.fromJson(content, JsonObject::class.java)

            val deadFunctions = mutableListOf<DeadFunction>()
            val deadArray = json.getAsJsonArray("dead_functions")

            deadArray?.forEach { element ->
                val obj = element.asJsonObject
                deadFunctions.add(
                    DeadFunction(
                        module = obj.get("module").asString,
                        functionName = obj.get("function").asString,
                        filePath = obj.get("file").asString,
                        lineNumber = obj.get("line").asInt
                    )
                )
            }

            val stats = json.getAsJsonObject("statistics")

            DeadCodeReport(
                sessionId = json.get("session_id").asString,
                totalInstrumented = stats.get("total_instrumented").asInt,
                totalCalled = stats.get("total_called").asInt,
                deadCount = stats.get("dead_count").asInt,
                deadPercentage = stats.get("dead_percentage").asDouble,
                deadFunctions = deadFunctions
            )
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    data class DeadCodeReport(
        val sessionId: String,
        val totalInstrumented: Int,
        val totalCalled: Int,
        val deadCount: Int,
        val deadPercentage: Double,
        val deadFunctions: List<DeadFunction>
    )

    data class DeadFunction(
        val module: String,
        val functionName: String,
        val filePath: String,
        val lineNumber: Int
    )

    /**
     * Parse performance report JSON.
     */
    fun parsePerformanceReport(file: File): PerformanceReport? {
        return try {
            val content = Files.readString(file.toPath())
            val json = gson.fromJson(content, JsonObject::class.java)

            val functionMetrics = mutableListOf<FunctionMetrics>()
            val metricsArray = json.getAsJsonArray("function_metrics")

            metricsArray?.forEach { element ->
                val obj = element.asJsonObject
                functionMetrics.add(
                    FunctionMetrics(
                        module = obj.get("module").asString,
                        functionName = obj.get("function").asString,
                        callCount = obj.get("call_count").asInt,
                        totalTimeMs = obj.get("total_time_ms").asDouble,
                        avgTimeMs = obj.get("avg_time_ms").asDouble,
                        minTimeMs = obj.get("min_time_ms").asDouble,
                        maxTimeMs = obj.get("max_time_ms").asDouble,
                        avgMemoryMb = obj.get("avg_memory_mb")?.asDouble ?: 0.0,
                        avgCpuPercent = obj.get("avg_cpu_percent")?.asDouble ?: 0.0
                    )
                )
            }

            // Sort by total time descending (hotspots first)
            functionMetrics.sortByDescending { it.totalTimeMs }

            val stats = json.getAsJsonObject("statistics")

            PerformanceReport(
                sessionId = json.get("session_id").asString,
                processId = json.get("process_id")?.asInt,
                startTime = json.get("start_time")?.asDouble,
                totalCalls = stats.get("total_calls").asInt,
                totalDurationMs = stats.get("total_duration_ms").asDouble,
                avgCallDurationMs = stats.get("avg_call_duration_ms")?.asDouble ?: 0.0,
                functionMetrics = functionMetrics
            )
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    data class PerformanceReport(
        val sessionId: String,
        val processId: Int?,
        val startTime: Double?,
        val totalCalls: Int,
        val totalDurationMs: Double,
        val avgCallDurationMs: Double,
        val functionMetrics: List<FunctionMetrics>
    )

    data class FunctionMetrics(
        val module: String,
        val functionName: String,
        val callCount: Int,
        val totalTimeMs: Double,
        val avgTimeMs: Double,
        val minTimeMs: Double,
        val maxTimeMs: Double,
        val avgMemoryMb: Double,
        val avgCpuPercent: Double
    )
}
